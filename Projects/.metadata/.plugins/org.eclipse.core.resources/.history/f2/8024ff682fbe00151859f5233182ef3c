package spell;
import java.util.List;
import java.util.ArrayList;
public class Dictionary implements ITrie{
	char[] alphabet = new char[26];
	Dictionary(){
		root = new Node();
		nodeCount = 0;
		wordCount = 0;
		alphabet[0] ='a';
		alphabet[1] = 'b';
		alphabet[2] = 'c';
		alphabet[3] = 'd';
		alphabet[4] = 'e';
		alphabet[5] = 'f';
		alphabet[6] = 'g';
		alphabet[7] = 'h';
		alphabet[8] = 'i';
		alphabet[9]= 'j';
		alphabet[10] = 'k';
		alphabet[11] = 'l';
		alphabet[12] = 'm';
		alphabet[13] = 'n';
		alphabet[14] = 'o';
		alphabet[15] = 'p';
		alphabet[16] = 'q';
		alphabet[17] = 'r';
		alphabet[18] = 's';
		alphabet[19] = 't';
		alphabet[20] = 'u';
		alphabet[21] = 'v';
		alphabet[22] = 'w';
		alphabet[23] = 'x';
		alphabet[24] = 'y';
		alphabet[25] = 'z';
	}
	
	private Node root;
	private int nodeCount;
	private int wordCount;
	@Override
	public void add(String word) {
		insertReflexive(root, word, 0, word.length());
	}
	
	private void insertReflexive(Node n, String s, int i, int max){
		if(n.nodes[s.charAt(i)] == null){
			n.nodes[s.charAt(i)] = new Node();
			nodeCount++;
		}
		if(i==max){
			if(n.nodes[s.charAt(i)].getValue()==0)
				wordCount++;
			n.nodes[s.charAt(i)].increaseCount();
			return;
		}
		else{
			insertReflexive(n.nodes[s.charAt(i)],s,++i,max);
		}
	}

	@Override
	public INode find(String word) {
		return findReflexive(root, word, 0,word.length());
		
	}
	
	private INode findReflexive(Node n, String s, int i, int max){
		if(n.nodes[s.charAt(i) - 'a'] == null){
			return null;
		}
		if(i==max){
			return n.nodes[s.charAt(i) - 'a'];
		}
		else{
			return findReflexive(n.nodes[s.charAt(i)-'a'],s,++i,max);
		}
		
	}
	
	@Override
	public String toString(){
		StringBuilder word = new StringBuilder();
		StringBuilder output = new StringBuilder();
		toStringHelper(root, word, output);
		return output.toString();
	}
	private void toStringHelper(Node n, StringBuilder word, StringBuilder output){
		if(n==null)
			return;
		if(n.getValue() > 0){
			output.append(word.toString() + "\n");
		}
		else{
			for(int i=0;i<26;i++){
				word.append('a'+i);
				toStringHelper(n.nodes[i],word,output);
				word.setLength(word.length()-1);
			}
		}
	}
//	public boolean equals(ITrie trie){
//		if(wordCount != trie.getWordCount() || nodeCount!=trie.getNodeCount())
//			return false;
//		else return equalsReflexive(root, trie.root);
//	}
//	private boolean equalsReflexive(Node n1, Node n2){
//		for(int i=0;i<26;i++){
//			if(n1.nodes[i]!=n2.nodes[i])
//				return false;
//			else if(n1.nodes[i].getValue()!=n2.nodes[i].getValue())
//				return false;
//			else return equalsReflexive(n1.nodes[i],n2.nodes[i]);
//		}
//		return true;
//	}
	
	@Override
	public int getWordCount() {
		return wordCount;
	}

	@Override
	public int getNodeCount() {
		return nodeCount;
	}
	
	public String[] modify(String word){
		
		
	}
	public String[] deletion(String word){
		
	}
	public void insertion(List<String> newWords, String word){
		StringBuilder sb = new StringBuilder();
		for(int i=0;i<26;i++){					//char to add
			
			for(int j=0;j<word.length();j++){	//index to add
				sb.delete(0,word.length()+1);		//generating new word. Delete sb
				for(int k=0;k<word.length();k++){//current index
					if(j==k){
						sb.append(alphabet[i]);
						sb.append(word.charAt(k));
					}
					else
						sb.append(word.charAt(k));
				}
			}
			newWords.add(sb.toString());	//add word
		}
	}
	
	public void trasposition(List<String> newWords, String word){
		
	}
	
	public void alteration(List<String> newWords, String word){
		
	}
}
